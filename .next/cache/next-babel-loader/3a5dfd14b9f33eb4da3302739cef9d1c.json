{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports[\"default\"] = exports.INITIAL_CSS_LOAD_ERROR = exports.looseToArray = void 0;\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\nvar _router = require(\"../next-server/lib/router/router\");\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../next-server/lib/router/utils/get-asset-path-from-route\"));\nvar _isDynamic = require(\"../next-server/lib/router/utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"../next-server/lib/router/utils/parse-relative-url\");\nvar looseToArray = function looseToArray(input) {\n  return [].slice.call(input);\n};\nexports.looseToArray = looseToArray;\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\nfunction pageLoadError(route) {\n  return (0, _router.markLoadingError)(new Error(\"Error loading \".concat(route)));\n}\nvar INITIAL_CSS_LOAD_ERROR = Symbol('INITIAL_CSS_LOAD_ERROR');\nexports.INITIAL_CSS_LOAD_ERROR = INITIAL_CSS_LOAD_ERROR;\nvar relPrefetch = hasRel('preload') && !hasRel('prefetch') ?\n// https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' :\n// https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nvar relPreload = hasRel('preload') ? 'preload' : relPrefetch;\nvar relPreloadStyle = 'fetch';\nvar hasNoModule = 'noModule' in document.createElement('script');\nfunction normalizeRoute(route) {\n  if (route[0] !== '/') {\n    throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\".concat(route, \"\\\"\"));\n  }\n  if (route === '/') return route;\n  return route.replace(/\\/$/, '');\n}\nfunction appendLink(href, rel, as, link) {\n  return new Promise(function (res, rej) {\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n    if (as) link.as = as;\n    link.rel = rel;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\nfunction loadScript(url) {\n  return new Promise(function (res, rej) {\n    var script = document.createElement('script');\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module';\n    }\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    script.src = url;\n    script.onload = res;\n    script.onerror = function () {\n      return rej(pageLoadError(url));\n    };\n    document.body.appendChild(script);\n  });\n}\nvar PageLoader = /*#__PURE__*/function () {\n  function PageLoader(buildId, assetPrefix, initialPage) {\n    _classCallCheck(this, PageLoader);\n    this.initialPage = void 0;\n    this.buildId = void 0;\n    this.assetPrefix = void 0;\n    this.pageCache = void 0;\n    this.pageRegisterEvents = void 0;\n    this.loadingRoutes = void 0;\n    this.promisedBuildManifest = void 0;\n    this.promisedSsgManifest = void 0;\n    this.promisedDevPagesManifest = void 0;\n    this.initialPage = initialPage;\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.pageRegisterEvents = (0, _mitt[\"default\"])();\n    this.loadingRoutes = {\n      // By default these 2 pages are being loaded in the initial html\n      '/_app': true\n    }; // TODO: get rid of this limitation for rendering the error page\n    if (initialPage !== '/_error') {\n      this.loadingRoutes[initialPage] = true;\n    }\n    this.promisedBuildManifest = new Promise(function (resolve) {\n      if (window.__BUILD_MANIFEST) {\n        resolve(window.__BUILD_MANIFEST);\n      } else {\n        ;\n        window.__BUILD_MANIFEST_CB = function () {\n          resolve(window.__BUILD_MANIFEST);\n        };\n      }\n    }); /** @type {Promise<Set<string>>} */\n    this.promisedSsgManifest = new Promise(function (resolve) {\n      if (window.__SSG_MANIFEST) {\n        resolve(window.__SSG_MANIFEST);\n      } else {\n        ;\n        window.__SSG_MANIFEST_CB = function () {\n          resolve(window.__SSG_MANIFEST);\n        };\n      }\n    });\n  }\n  return _createClass(PageLoader, [{\n    key: \"getPageList\",\n    value: function getPageList() {\n      if (true) {\n        return this.promisedBuildManifest.then(function (buildManifest) {\n          return buildManifest.sortedPages;\n        });\n      } else {\n        if (window.__DEV_PAGES_MANIFEST) {\n          return window.__DEV_PAGES_MANIFEST.pages;\n        } else {\n          if (!this.promisedDevPagesManifest) {\n            this.promisedDevPagesManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/development/_devPagesManifest.json\")).then(function (res) {\n              return res.json();\n            }).then(function (manifest) {\n              ;\n              window.__DEV_PAGES_MANIFEST = manifest;\n              return manifest.pages;\n            })[\"catch\"](function (err) {\n              console.log(\"Failed to fetch devPagesManifest\", err);\n            });\n          }\n          return this.promisedDevPagesManifest;\n        }\n      }\n    } // Returns a promise for the dependencies for a particular route\n  }, {\n    key: \"getDependencies\",\n    value: function getDependencies(route) {\n      var _this2 = this;\n      return this.promisedBuildManifest.then(function (m) {\n        return m[route] ? m[route].map(function (url) {\n          return \"\".concat(_this2.assetPrefix, \"/_next/\").concat(encodeURI(url));\n        }) : Promise.reject(pageLoadError(route));\n      });\n    } /**\n      * @param {string} href the route href (file-system path)\n      * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n      */\n  }, {\n    key: \"getDataHref\",\n    value: function getDataHref(href, asPath, ssg, locale) {\n      var _this3 = this;\n      var _ref = (0, _parseRelativeUrl.parseRelativeUrl)(href),\n        hrefPathname = _ref.pathname,\n        query = _ref.query,\n        search = _ref.search;\n      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(asPath),\n        asPathname = _ref2.pathname;\n      var route = normalizeRoute(hrefPathname);\n      var getHrefForSlug = function getHrefForSlug(path) {\n        var dataRoute = (0, _router.addLocale)((0, _getAssetPathFromRoute[\"default\"])(path, '.json'), locale);\n        return (0, _router.addBasePath)(\"/_next/data/\".concat(_this3.buildId).concat(dataRoute).concat(ssg ? '' : search));\n      };\n      var isDynamic = (0, _isDynamic.isDynamicRoute)(route);\n      var interpolatedRoute = isDynamic ? (0, _router.interpolateAs)(hrefPathname, asPathname, query).result : '';\n      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);\n    } /**\n      * @param {string} href the route href (file-system path)\n      * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes\n      */\n  }, {\n    key: \"prefetchData\",\n    value: function prefetchData(href, asPath, locale) {\n      var _this4 = this;\n      var _ref3 = (0, _parseRelativeUrl.parseRelativeUrl)(href),\n        hrefPathname = _ref3.pathname;\n      var route = normalizeRoute(hrefPathname);\n      return this.promisedSsgManifest.then(function (s, _dataHref) {\n        return (\n          // Check if the route requires a data file\n          s.has(route) && (\n          // Try to generate data href, noop when falsy\n          _dataHref = _this4.getDataHref(href, asPath, true, locale)) &&\n          // noop when data has already been prefetched (dedupe)\n          !document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(_dataHref, \"\\\"]\")) &&\n          // Inject the `<link rel=prefetch>` tag for above computed `href`.\n          appendLink(_dataHref, relPrefetch, 'fetch')[\"catch\"](function () {/* ignore prefetch error */})\n        );\n      });\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(route) {\n      var _this5 = this;\n      route = normalizeRoute(route);\n      return new Promise(function (resolve, reject) {\n        // If there's a cached version of the page, let's use it.\n        var cachedPage = _this5.pageCache[route];\n        if (cachedPage) {\n          if ('error' in cachedPage) {\n            reject(cachedPage.error);\n          } else {\n            resolve(cachedPage);\n          }\n          return;\n        }\n        var _fire = function fire(pageToCache) {\n          _this5.pageRegisterEvents.off(route, _fire);\n          delete _this5.loadingRoutes[route];\n          if ('error' in pageToCache) {\n            reject(pageToCache.error);\n          } else {\n            resolve(pageToCache);\n          }\n        }; // Register a listener to get the page\n        _this5.pageRegisterEvents.on(route, _fire);\n        if (!_this5.loadingRoutes[route]) {\n          _this5.loadingRoutes[route] = true;\n          if (true) {\n            _this5.getDependencies(route).then(function (deps) {\n              var pending = [];\n              deps.forEach(function (d) {\n                if (d.endsWith('.js') && !document.querySelector(\"script[src^=\\\"\".concat(d, \"\\\"]\"))) {\n                  pending.push(loadScript(d));\n                } // Prefetch CSS as it'll be needed when the page JavaScript\n                // evaluates. This will only trigger if explicit prefetching is\n                // disabled for a <Link>... prefetching in this case is desirable\n                // because we *know* it's going to be used very soon (page was\n                // loaded).\n                if (d.endsWith('.css') && !document.querySelector(\"link[rel=\\\"\".concat(relPreload, \"\\\"][href^=\\\"\").concat(d, \"\\\"]\"))) {\n                  // This is not pushed into `pending` because we don't need to\n                  // wait for these to resolve. To prevent an unhandled\n                  // rejection, we swallow the error which is handled later in\n                  // the rendering cycle (this is just a preload optimization).\n                  appendLink(d, relPreload, relPreloadStyle)[\"catch\"](function () {/* ignore preload error */});\n                }\n              });\n              return Promise.all(pending);\n            })[\"catch\"](function (err) {\n              // Mark the page as failed to load if any of its required scripts\n              // fail to load:\n              _this5.pageCache[route] = {\n                error: err\n              };\n              _fire({\n                error: err\n              });\n            });\n          } else {\n            // Development only. In production the page file is part of the build manifest\n            route = normalizeRoute(route);\n            var scriptRoute = (0, _getAssetPathFromRoute[\"default\"])(route, '.js');\n            var url = \"\".concat(_this5.assetPrefix, \"/_next/static/chunks/pages\").concat(encodeURI(scriptRoute));\n            loadScript(url)[\"catch\"](function (err) {\n              // Mark the page as failed to load if its script fails to load:\n              _this5.pageCache[route] = {\n                error: err\n              };\n              _fire({\n                error: err\n              });\n            });\n          }\n        }\n      });\n    } // This method if called by the route code.\n  }, {\n    key: \"registerPage\",\n    value: function registerPage(route, regFn) {\n      var _this6 = this;\n      var _this = this;\n      var register = /*#__PURE__*/function () {\n        var _register = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(styleSheets) {\n          var mod, pageData;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return regFn();\n              case 3:\n                mod = _context.sent;\n                pageData = {\n                  page: mod[\"default\"] || mod,\n                  mod: mod,\n                  styleSheets: styleSheets\n                };\n                _this.pageCache[route] = pageData;\n                _this.pageRegisterEvents.emit(route, pageData);\n                _context.next = 13;\n                break;\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](0);\n                _this.pageCache[route] = {\n                  error: _context.t0\n                };\n                _this.pageRegisterEvents.emit(route, {\n                  error: _context.t0\n                });\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, null, [[0, 9]]);\n        }));\n        function register(_x) {\n          return _register.apply(this, arguments);\n        }\n        return register;\n      }();\n      if (false) {\n        // Wait for webpack to become idle if it's not.\n        // More info: https://github.com/vercel/next.js/pull/1511\n        if (module.hot && module.hot.status() !== 'idle') {\n          console.log(\"Waiting for webpack to become \\\"idle\\\" to initialize the page: \\\"\".concat(route, \"\\\"\"));\n          var _check = function check(status) {\n            if (status === 'idle') {\n              ;\n              module.hot.removeStatusHandler(_check);\n              register(/* css is handled via style-loader in development */[]);\n            }\n          };\n          module.hot.status(_check);\n          return;\n        }\n      }\n      function fetchStyleSheet(href) {\n        return fetch(href).then(function (res) {\n          if (!res.ok) throw pageLoadError(href);\n          return res.text().then(function (text) {\n            return {\n              href: href,\n              text: text\n            };\n          });\n        });\n      }\n      var isInitialLoad = route === this.initialPage;\n      var promisedDeps =\n      // Shared styles will already be on the page:\n      route === '/_app' || // We use `style-loader` in development:\n      false ? Promise.resolve([]) :\n      // Tests that this does not block hydration:\n      // test/integration/css-fixtures/hydrate-without-deps/\n      (isInitialLoad ? Promise.resolve(looseToArray(document.querySelectorAll('link[data-n-p]')).map(function (e) {\n        return e.getAttribute('href');\n      })) : this.getDependencies(route).then(function (deps) {\n        return deps.filter(function (d) {\n          return d.endsWith('.css');\n        });\n      })).then(function (cssFiles) {\n        return (\n          // These files should've already been fetched by now, so this\n          // should resolve instantly.\n          Promise.all(cssFiles.map(function (d) {\n            return fetchStyleSheet(d);\n          }))[\"catch\"](function (err) {\n            if (isInitialLoad) {\n              Object.defineProperty(err, INITIAL_CSS_LOAD_ERROR, {});\n            }\n            throw err;\n          })\n        );\n      });\n      promisedDeps.then(function (deps) {\n        return register(deps);\n      }, function (error) {\n        _this6.pageCache[route] = {\n          error: error\n        };\n        _this6.pageRegisterEvents.emit(route, {\n          error: error\n        });\n      });\n    } /**\n      * @param {string} route\n      * @param {boolean} [isDependency]\n      */\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(route, isDependency) {\n      var _this7 = this;\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      var cn;\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      } /** @type {string} */\n      var url;\n      if (isDependency) {\n        url = route;\n      } else {\n        if (false) {\n          route = normalizeRoute(route);\n          var ext = process.env.__NEXT_MODERN_BUILD && hasNoModule ? '.module.js' : '.js';\n          var scriptRoute = (0, _getAssetPathFromRoute[\"default\"])(route, ext);\n          url = \"\".concat(this.assetPrefix, \"/_next/static/\").concat(encodeURIComponent(this.buildId), \"/pages\").concat(encodeURI(scriptRoute));\n        }\n      }\n      return Promise.all(document.querySelector(\"link[rel=\\\"\".concat(relPrefetch, \"\\\"][href^=\\\"\").concat(url, \"\\\"]\")) ? [] : [url && appendLink(url, relPrefetch, url.endsWith('.css') ? relPreloadStyle : 'script'), true && !isDependency && this.getDependencies(route).then(function (urls) {\n        return Promise.all(urls.map(function (dependencyUrl) {\n          return _this7.prefetch(dependencyUrl, true);\n        }));\n      })]).then(\n      // do not return any data\n      function () {},\n      // swallow prefetch errors\n      function () {});\n    }\n  }]);\n}();\nexports[\"default\"] = PageLoader;","map":null,"metadata":{},"sourceType":"script"}