{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nexports.__esModule = true;\nexports.default = prepareDestination;\nvar _querystring = require(\"./querystring\");\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction prepareDestination(destination, params, query, appendParamsToQuery, basePath) {\n  let parsedDestination = {}; // clone query so we don't modify the original\n  query = Object.assign({}, query);\n  delete query.__nextLocale;\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href\n    } = new URL(destination);\n    parsedDestination = {\n      pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href\n    };\n  }\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath,\n  // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`;\n      const queryCompiler = pathToRegexp.compile(value, {\n        validate: false\n      });\n      value = queryCompiler(params).substr(1);\n    }\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params);\n  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key];\n      }\n    }\n  }\n  const shouldAddBasePath = destination.startsWith('/') && basePath;\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(params)}`;\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`);\n    }\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl,\n    parsedDestination\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["prepareDestination","destination","params","query","appendParamsToQuery","basePath","parsedDestination","Object","assign","__nextLocale","startsWith","pathname","searchParams","hash","hostname","port","protocol","search","href","URL","destQuery","destPath","destPathParamKeys","pathToRegexp","destPathParams","map","key","name","destinationCompiler","compile","validate","newUrl","strOrArray","entries","value","Array","isArray","queryCompiler","substr","paramKeys","keys","some","includes","shouldAddBasePath","split","err","message","match","Error"],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\ntype Params = { [param: string]: any }\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean,\n  basePath: string\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  delete query.__nextLocale\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = pathToRegexp.compile(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params)\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(\n      params\n    )}`\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}